#define _XOPEN_SOURCE
#include <unistd.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#define HEIGHT 16384
#define WIDTH 1129
#define DEPTH 8
#define SIZE HEIGHT * WIDTH * DEPTH
#define DCM HEIGHT * WIDTH

/* Map a single hash byte to an enumerated value. */
int enum_hashbyte(char a) {
int i, j;
i = (int)a;
if((i >= 46) && (i <= 57))
j = i - 46;
else if ((i >= 65) && (i <= 90))
j = i - 53;
else if ((i >= 97) && (i <= 122))
j = i - 59;
return j;
}
/* Map 3 hash bytes to an enumerated value. */
int enum_hashtriplet(char a, char b, char c) {
return (((enum_hashbyte(c)%4)*4096)+(enum_hashbyte(a)*64)+enum_hashbyte(b));
}
/* Merge two vectors. */
void merge(char *vector1, char *vector2) {
int i;
for(i=0; i < WIDTH; i++)
vector1[i] &= vector2[i];
}
/* Returns the bit in the vector at the passed index position */
int get_vector_bit(char *vector, int index) {
return ((vector[(index/8)]&(1<<(index%8)))>>(index%8));
}
/* Counts the number of plaintext pairs in the passed vector */
int count_vector_bits(char *vector) {
int i, count=0;
for(i=0; i < 9025; i++)
count += get_vector_bit(vector, i);
return count;


}
/* Print the plaintext pairs that each ON bit in the vector enumerates. */
void print_vector(char *vector) {
int i, a, b, val;
for(i=0; i < 9025; i++) {
if(get_vector_bit(vector, i) == 1) { // If bit is on,
a = i / 95;
// calculate the
b = i - (a * 95);
// plaintext pair
printf("%c%c ",a+32, b+32); // and print it.
}
}
printf("\n");
}
/* Barf a message and exit. */
void barf(char *message, char *extra) {
printf(message, extra);
exit(1);
}
/* Crack a 4-character password using generated 4char.ppm file. */
int main(int argc, char *argv[]) {
char *pass, plain[5];
unsigned char bin_vector1[WIDTH], bin_vector2[WIDTH], temp_vector[WIDTH];
char prob_vector1[2][9025];
char prob_vector2[2][9025];
int a, b, i, j, len, pv1_len=0, pv2_len=0;
FILE *fd;

if(argc < 1)
barf("Usage: %s <password hash> (will use the file 4char.ppm)\n", argv[0]);

if(!(fd = fopen("4char.ppm", "r")))
barf("Fatal: Couldn't open PPM file for reading.\n", NULL);

pass = argv[1]; // First argument is password hash

printf("Filtering possible plaintext bytes for the first two characters:\n");

fseek(fd,(DCM*0)+enum_hashtriplet(pass[2], pass[3], pass[4])*WIDTH, SEEK_SET);
fread(bin_vector1, WIDTH, 1, fd); // Read the vector associating bytes 2-4 of hash.

len = count_vector_bits(bin_vector1);
printf("only 1 vector of 4:\t%d plaintext pairs, with %0.2f%% saturation\n", len, len*100.0/9025.0);

fseek(fd,(DCM*1)+enum_hashtriplet(pass[4], pass[5], pass[6])*WIDTH, SEEK_SET);
fread(temp_vector, WIDTH, 1, fd); // Read the vector associating bytes 4-6 of hash.
merge(bin_vector1, temp_vector); // Merge it with the first vector.

len = count_vector_bits(bin_vector1);
printf("vectors 1 AND 2 merged:\t%d plaintext pairs, with %0.2f%% saturation\n", len,len*100.0/9025.0);


fseek(fd,(DCM*2)+enum_hashtriplet(pass[6], pass[7], pass[8])*WIDTH, SEEK_SET);
fread(temp_vector, WIDTH, 1, fd); // Read the vector associating bytes 6-8 of hash.
merge(bin_vector1, temp_vector); // Merge it with the first two vectors.
len = count_vector_bits(bin_vector1);

printf("first 3 vectors merged:\t%d plaintext pairs, with %0.2f%% saturation\n", len,len*100.0/9025.0);

fseek(fd,(DCM*3)+enum_hashtriplet(pass[8], pass[9],pass[10])*WIDTH, SEEK_SET);
fread(temp_vector, WIDTH, 1, fd); // Read the vector associatind bytes 8-10 of hash.
merge(bin_vector1, temp_vector); // Merge it with the othes vectors.

len = count_vector_bits(bin_vector1);
printf("all 4 vectors merged:\t%d plaintext pairs, with %0.2f%% saturation\n", len,len*100.0/9025.0);
printf("Possible plaintext pairs for the first two bytes:\n");
print_vector(bin_vector1);

printf("\nFiltering possible plaintext bytes for the last two characters:\n");

fseek(fd,(DCM*4)+enum_hashtriplet(pass[2], pass[3], pass[4])*WIDTH, SEEK_SET);
fread(bin_vector2, WIDTH, 1, fd); // Read the vector associating bytes 2-4 of hash.
len = count_vector_bits(bin_vector2);

printf("only 1 vector of 4:\t%d plaintext pairs, with %0.2f%% saturation\n", len, len*100.0/9025.0);

fseek(fd,(DCM*5)+enum_hashtriplet(pass[4], pass[5], pass[6])*WIDTH, SEEK_SET);
fread(temp_vector, WIDTH, 1, fd); // Read the vector associating bytes 4-6 of hash.
merge(bin_vector2, temp_vector); // Merge it with the first vector.

len = count_vector_bits(bin_vector2);
printf("vectors 1 AND 2 merged:\t%d plaintext pairs, with %0.2f%% saturation\n", len,
len*100.0/9025.0);

fseek(fd,(DCM*6)+enum_hashtriplet(pass[6], pass[7], pass[8])*WIDTH, SEEK_SET);
fread(temp_vector, WIDTH, 1, fd); // Read the vector associating bytes 6-8 of hash.
merge(bin_vector2, temp_vector); // Merge it with the first two vectors.

len = count_vector_bits(bin_vector2);
printf("first 3 vectors merged:\t%d plaintext pairs, with %0.2f%% saturation\n", len,len*100.0/9025.0);

fseek(fd,(DCM*7)+enum_hashtriplet(pass[8], pass[9],pass[10])*WIDTH, SEEK_SET);
fread(temp_vector, WIDTH, 1, fd); // Read the vector associatind bytes 8-10 of hash.
merge(bin_vector2, temp_vector); // Merge it with the othes vectors.

len = count_vector_bits(bin_vector2);
printf("all 4 vectors merged:\t%d plaintext pairs, with %0.2f%% saturation\n", len,len*100.0/9025.0);

printf("Possible plaintext pairs for the last two bytes:\n");
print_vector(bin_vector2);
printf("Building probability vectors...\n");

for(i=0; i < 9025; i++) { // Find possible first two plaintext bytes.
if(get_vector_bit(bin_vector1, i)==1) {;
prob_vector1[0][pv1_len] = i / 95;
prob_vector1[1][pv1_len] = i - (prob_vector1[0][pv1_len] * 95);
pv1_len++;
}
}

for(i=0; i < 9025; i++) { // Find possible last two plaintext bytes.
if(get_vector_bit(bin_vector2, i)) {
 prob_vector2[0][pv2_len] = i / 95;
 prob_vector2[1][pv2_len] = i - (prob_vector2[0][pv2_len] * 95);
 pv2_len++;
}
}

printf("Cracking remaining %d possibilites..\n", pv1_len*pv2_len);
for(i=0; i < pv1_len; i++) {
for(j=0; j < pv2_len; j++) {
plain[0] = prob_vector1[0][i] + 32;
plain[1] = prob_vector1[1][i] + 32;
plain[2] = prob_vector2[0][j] + 32;
plain[3] = prob_vector2[1][j] + 32;
plain[4] = 0;

if(strcmp(crypt(plain, "je"), pass) == 0) {
printf("Password : %s\n", plain);
i = 31337;
j = 31337;
}
}
}
if(i < 31337)
printf("Password wasn't salted with 'je' or is not 4 chars long.\n");
fclose(fd);
}

================================OUTPUT=============================================
#cd Desktop
#./crypt_test h4% je the excution display the 
password "h4R%" with salt "je" hashes to ==> jeMqqfIfPNNTE
next we are going to compile theour program
#gcc -O3 -o ppm_crack ppm_crack.c -lcrypt
next excution of program  with password jeMqqfIfPNNTE
#./ppm_crack jeMqqfIfPNNTE

Filtering possible plaintext bytes for the first two characters:
only 1 vector of 4:	3801 plaintext pairs, with 42.12% saturation
vectors 1 AND 2 merged:	1666 plaintext pairs, with 18.46% saturation
first 3 vectors merged:	695 plaintext pairs, with 7.70% saturation
all 4 vectors merged:	287 plaintext pairs, with 3.18% saturation

it will show the below matching Possible plaintext pairs for the first two bytes

similiar form the last two byte of character 

Filtering possible plaintext bytes for the last two characters:
only 1 vector of 4:	3821 plaintext pairs, with 42.34% saturation
vectors 1 AND 2 merged:	1677 plaintext pairs, with 18.58% saturation
first 3 vectors merged:	713 plaintext pairs, with 7.90% saturation
all 4 vectors merged:	297 plaintext pairs, with 3.29% saturation

it will also show the Possible plaintext pairs for the last two bytes:

there will much differnce between saturation of first two characters and last two characters  

atlast Building probability vectors

the Cracking remaining 85239 possibilites still there are possibilites of cracking of password

Password : h4R%

These programs are proof-of-concept hacks, which take advantage of the
bit diffusion provided by hash functions. There are other time-space trade-off
attacks, and some have become quite popular. RainbowCrack is a popular
tool, which has support for multiple algorithms. If you want to learn more,
consult the Internet.
